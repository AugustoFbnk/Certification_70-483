//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.42000
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Generic;

namespace Certification70_483._03_DebugApplicationsAndImplementSecurity._02_PerformSymmetricAndAsymmetricEncryption
{
    /// <summary>
    /// A set implementation that uses hashing
    /// </summary>
    public class Example22
    {

        public static void Start()
        {
            var stringList = new Set<string>();
            stringList.Insert("string a");
            stringList.Insert("string b");
            stringList.Insert("string c");
            stringList.Insert("string a");
        }

        class Set<T>
        {
            private List<T>[] buckets = new List<T>[100];
            public void Insert(T item)
            {
                int bucket = GetBucket(item.GetHashCode());
                if (Contains(item, bucket))
                    return;
                if (buckets[bucket] == null)
                    buckets[bucket] = new List<T>();
                buckets[bucket].Add(item);
            }
            public bool Contains(T item)
            {
                return Contains(item, GetBucket(item.GetHashCode()));
            }
            private int GetBucket(int hashcode)
            {
                // A Hash code can be negative. To make sure that you end up with a positive 
                // value cast the value to an unsigned int. The unchecked block makes sure that 
                // you can cast a value larger then int to an int safely.
                unchecked
                {
                    return (int)((uint)hashcode % (uint)buckets.Length);
                }
            }
            private bool Contains(T item, int bucket)
            {
                if (buckets[bucket] != null)
                    foreach (T member in buckets[bucket])
                        if (member.Equals(item))
                            return true;
                return false;
            }
        }
    }
}
